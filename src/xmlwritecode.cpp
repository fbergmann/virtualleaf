// Automatically produced by perl script "make_xmlwritecode.pl". DO NOT EDIT

#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xmlreader.h>
#include "xmlwrite.h"
#include <string>

static const std::string _module_id("$Id$");

void XMLIO::XMLWriteLeafSourceCode(xmlNode *parent) {

  // Embed the code in our xml file, so we can reconstruct the model we used
  // to produce it... 

xmlChar *sourcecode = (xmlChar *)"#include <fstream>\n#include <sstream>\n#include <cstring>\n#include <functional> \n#include <getopt.h>\n#include <cerrno>\n#include \"mesh.h\"\n#include \"parameter.h\"\n#include \"random.h\"\n#include \"pi.h\"\n#include \"cellitem.h\"\n#include \"canvas.h\"\n#include \"cell.h\"\n#include \"output.h\"\n#include <qwidget.h>\n#include <q3process.h>\n#include <qapplication.h>\n#include <QDesktopWidget>\n#include <QGraphicsScene>\n#include <QMessageBox>\n//Added by qt3to4:\n#include <QMouseEvent>\n\n#include <unistd.h>\n#include <q3textstream.h> \n\n\n#ifdef HAVE_QWT\n#include \"data_plot.h\"\n#endif\n#include <QPalette>\n#include <QBrush>\n#include <QToolTip>\n#include \"simplugin.h\"\n#include \"testplugin.h\"\n\n/* #define _xstr_(s) _str_(s)\n#define _str_(s) #s\n#include _xstr_(REACTIONS_HEADER)\n*/\nextern Parameter par;\n\nMainBase *main_window = 0;\ndouble auxin_account = 0.;\n\n\n\nTestPlugin *plugin = new TestPlugin();\n\n#ifdef XFIGGRAPHICS\n#define TIMESTEP double Graphics::TimeStep(void)\n#endif\n\nclass PrintNode {\npublic:\n  void operator() (const Node &amp;n) const \n  {\n    cerr << n.Index() << \": \" << n <<  endl;\n  }\n};\n\n\nclass EdgeSource {\n	\npublic:\n  void operator() (Cell &amp;c) {\n		\n    if (c.AtBoundaryP()) {\n      cerr << \"Cell \" << c.Index() << \" is a source cell.\\n\";\n      c.SetSource(0,par.source);\n    } else {\n      cerr << \"Cell \" << c.Index() << \" is _not_ a source cell.\\n\";\n    }\n  }\n	\n};\n\n\n\nclass CellInfo {\npublic:\n  void operator() (Cell &amp;c,std::ostream &amp;os) const {\n    os << \"Cell \" << c.index << \" says: \" << endl;\n    os << \"c.nodes.size() = \" << c.nodes.size() << endl;\n    for (list<Node *>::iterator i=c.nodes.begin();\n	 i!=c.nodes.end();\n	 i++) {\n      cerr << (*i)->Index() << \" \";\n    }\n    cerr << endl;\n  }\n};\n\ndouble PINSum(Cell &amp;c) {\n	\n	return c.Chemical(1) + c.SumTransporters(1);// + c.ReduceCellAndWalls<double>( complex_PijAj );\n	\n}\n\n\nclass DrawCell {\npublic:\n  void operator() (Cell &amp;c,QGraphicsScene &amp;canvas, MainBase &amp;m) const {\n    if (m.ShowBorderCellsP() || c.Boundary()==Cell::None) {\n      if (!m.ShowBoundaryOnlyP() &amp;&amp; !m.HideCellsP()) \n	if (m.ShowToolTipsP()) {\n	  QString info_string=QString(\"Cell %1, chemicals: ( %2, %3, %4, %5, %6)\\n %7 of PIN1 at walls.\\n Area is %8\\n PIN sum is %9\\n Circumference is %10\\n Boundary type is %11\").arg(c.Index()).arg(c.Chemical(0)).arg(c.Chemical(1)).arg(c.Chemical(2)).arg(c.Chemical(3)).arg(c.Chemical(4)).arg(c.SumTransporters(1)).arg(c.Area()).arg(PINSum(c)).arg(c.Circumference()).arg(c.BoundaryStr());\n					\n	  info_string += \"\\n\" + c.printednodelist();\n					\n	  c.Draw(&amp;canvas, info_string);\n	} else {\n	  c.Draw(&amp;canvas);\n	}\n      if (m.ShowCentersP())\n	c.DrawCenter(&amp;canvas);\n    if (m.ShowFluxesP())\n	c.DrawFluxes(&amp;canvas, par.arrowsize);\n			\n       }\n \n  }\n	\n};\n\nMesh mesh;\nbool batch=false;\n\n\nvoid MainBase::Plot(int resize_stride) {\n	\n  clear();\n    \n	\n  static int count=0;\n  if (resize_stride) {\n    if ( !((++count)%resize_stride) ) {\n      FitLeafToCanvas();\n    }\n  }\n  mesh.LoopCells(DrawCell(),canvas,*this);\n	\n  if (ShowNodeNumbersP()) \n    mesh.LoopNodes( bind2nd (mem_fun_ref ( &amp;Node::DrawIndex), &amp;canvas ) ) ;\n  if (ShowCellNumbersP()) \n    mesh.LoopCells( bind2nd (mem_fun_ref ( &amp;Cell::DrawIndex), &amp;canvas ) ) ;\n	\n  if (ShowCellAxesP()) \n    mesh.LoopCells( bind2nd (mem_fun_ref ( &amp;Cell::DrawAxis), &amp;canvas ) );\n	\n  if (ShowCellStrainP()) \n    mesh.LoopCells( bind2nd (mem_fun_ref ( &amp;Cell::DrawStrain), &amp;canvas ) );\n	\n  if (ShowWallsP())\n  \n    mesh.LoopWalls( bind2nd( mem_fun_ref( &amp;Wall::Draw ), &amp;canvas ) );\n	\n	if (ShowApoplastsP()) \n		mesh.LoopWalls( bind2nd( mem_fun_ref( &amp;Wall::DrawApoplast ), &amp;canvas ) );\n \n	if (ShowMeshP()) \n    mesh.DrawNodes(&amp;canvas);\n	\n  if (ShowBoundaryOnlyP()) \n    mesh.DrawBoundary(&amp;canvas);\n\n  \n	if ( ( batch || MovieFramesP() )) {\n		\n		static int frame = 0;\n		// frame numbers are sequential for the most frequently written file type.\n		// for the less frequently written file type they match the other type\n		if (!(count%par.storage_stride) )  {\n		\n			stringstream fname;\n			fname << par.datadir << \"/leaf.\";\n			fname.fill('0');\n			fname.width(6);\n	\n			/* \n			 fname << frame << \".pdf\";\n			if (par.storage_stride <= par.xml_storage_stride) {\n				frame++;\n			}\n			\n			// Write high-res JPG snapshot every plot step\n			Save(fname.str().c_str(), \"PDF\");\n			*/\n			\n			fname << frame << \".jpg\";\n			if (par.storage_stride <= par.xml_storage_stride) {\n				frame++;\n			}\n			\n			// Write high-res JPG snapshot every plot step\n			Save(fname.str().c_str(), \"JPEG\",1024,768);\n			\n		}\n	\n		if (!(count%par.xml_storage_stride)) {\n			stringstream fname;\n			fname << par.datadir << \"/leaf.\";\n			fname.fill('0');\n			fname.width(6);\n			fname << frame << \".xml\";\n	\n			if (par.xml_storage_stride < par.storage_stride) {\n				frame++;\n			}\n			// Write XML file every ten plot steps\n			mesh.XMLSave(fname.str().c_str(), XMLSettingsTree());\n		}\n		\n	}\n}\n\n\nvoid Cell::Flux(double *flux, double *D)  {\n	\n\n  // loop over cell edges\n	\n  for (int c=0;c<Cell::nchem;c++) flux[c]=0.;\n	\n  for (list<Wall *>::iterator i=walls.begin();\n       i!=walls.end();\n       i++) {\n		\n		\n    // leaf cannot take up chemicals from environment (\"no flux boundary\")\n    if ((*i)->c2->BoundaryPolP()) continue;\n		\n  	\n    // flux depends on edge length and concentration difference\n    for (int c=0;c<Cell::nchem;c++) {\n      double phi = (*i)->length * ( D[c] ) * ( (*i)->c2->chem[c] - chem[c] );\n			\n      if ((*i)->c1!=this) {\n	cerr << \"Warning, bad cells boundary: \" << (*i)->c1->index << \", \" << index << endl;\n      }\n			\n      flux[c] += phi;\n    }    \n  }\n	\n}\n\nINIT {\n	\n	if (leaffile) { \n    xmlNode *settings;\n    mesh.XMLRead(leaffile, &amp;settings);\n    main_window->XMLReadSettings(settings);\n    xmlFree(settings);\n    main_window->UserMessage(QString(\"Ready. Time is %1\").arg(mesh.getTimeHours().c_str()));\n		\n  } else {\n		\n	  Cell &amp;circle=mesh.CircularCell(0,0,10,10);\n    		\n    circle.SetTargetArea(circle.CalcArea());\n	  mesh.SetBaseArea();\n	// clean up chemicals \n	  for (int c=0; c<Cell::NChem(); c++) {\n		  circle.SetChemical(c, 0.);\n      }\n  }\n}\n\nTIMESTEP {\n	\n  static int i=0;\n  static int t=0;\n  static int ncells;\n	\n  if (!batch) {\n    UserMessage(QString(\"Time: %1\").arg(mesh.getTimeHours().c_str()),0);\n  }\n			 \n  ncells=mesh.NCells();\n		\n				\n  double dh;\n  		\n  if(DynamicCellsP()) {\n    dh = mesh.DisplaceNodes();\n			\n    // Only allow for node insertion, cell division and cell growth\n    // if the system has equillibrized\n    // i.e. cell wall tension equillibrization is much faster\n    // than biological processes, including division, cell wall yielding\n    // and cell expansion\n    mesh.InsertNodes(); // (this amounts to cell wall yielding)\n			\n    if ( (-dh) < par.energy_threshold) {\n				\n      mesh.IncreaseCellCapacityIfNecessary();\n		mesh.LoopCurrentCells(&amp;TestPlugin::CellHouseKeeping); // this includes cell division\n				\n      // Reaction diffusion	\n		/*CelltoCellTransport *transport_f = &amp;TestPlugin::CelltoCellTransport;\n      CellReaction *cellreaction_f = new plugin->CellDynamics();\n      WallReaction *wall_f = new WallDynamics();*/\n				\n      mesh.ReactDiffuse(plugin, par.rd_dt);\n		\n				\n      t++;\n				\n      Plot(par.resize_stride);\n		\n		/*QVector< QPair<double, int> > angles=mesh.VertexAnglesValues();\n		QString afname=QString(\"Angles/anglesvalues%1.dat\").arg(t,6,10,QChar('0'));\n		ofstream af(afname.toStdString().c_str());\n		*/\n		\n		/*for (QVector< QPair<qreal, int> >::const_iterator v=angles.begin();\n			 v!=angles.end();\n			 v++) {\n			af << v->first << \" \" << v->second << endl;\n			}\n			*/\n			}\n		\n			} else {\n			\n  /*  TransportFunction *transport_f = new CelltoCellTransport();\n    CellReaction *cellreaction_f = new CellDynamics();\n    WallReaction *wall_f = new WallDynamics();\n			\n    mesh.ReactDiffuse_New(transport_f, cellreaction_f, wall_f, par.rd_dt);*/\n				mesh.ReactDiffuse(plugin, par.rd_dt);\n		\n    Plot(par.resize_stride);\n			\n  }\n	\n	\n\n		\n		\n  i++;\n  return mesh.getTime();\n		\n}\n		\n		\n				\n/* Called if a cell is clicked */\nvoid Cell::OnClick(QMouseEvent *e) {\n					\n}\n				\n				\n\nvoid Wall::OnWallInsert(void) {\n				  \n\n}\n\n				\n				\n				\nint main(int argc,char **argv) {\n					\n  try {\n						\n\n    int c;\n\n						\n    char *leaffile=0;\n\n						\n    while (1) {\n							\n      //int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static struct option long_options[] = {\n	{\"batch\", 0, 0, 0},\n	{\"leaffile\", 2, 0, 0}\n      };\n		\n      // short option 'p' creates trouble for non-commandline usage on MacOSX. Option -p changed to -P (capital)\n      static char *short_options = \"bl\";\n      c = getopt_long (argc, argv, \"bl:\",\n		       long_options, &amp;option_index);\n      if (c == -1)\n	break;\n		\n		\n      if (c==0) {\n	printf (\"option %s\", long_options[option_index].name);\n	if (optarg)\n	  printf (\" with arg %s\", optarg);\n	printf (\"\\n\");\n			\n	c = short_options[option_index];\n      }\n		\n      switch (c) {\n      case 'b':\n	cerr << \"Running in batch mode\\n\";\n	batch=true;\n	break;\n				\n      case 'l':\n	leaffile=strdup(optarg);\n	if (!leaffile) {\n	  throw(\"Out of memory\");\n	}\n	printf(\"Reading leaf state file '%s'\\n\", leaffile);\n	break;\n				\n      case '?':\n	break;\n				\n      default:\n	printf (\"?? getopt returned character code 0%o ??\\n\", c);\n      }\n    }\n	  \n	  \n    if (optind < argc) {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n	printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n	  \n	  MakeDir(\"Angles\");\n    bool useGUI = !batch;\n    QApplication app(argc,argv,useGUI);\n						\n\n    \n    QPalette tooltippalette = QToolTip::palette();\n    QColor transparentcolor = QColor(tooltippalette.brush(QPalette::Window).color());\n\n    tooltippalette.setBrush (QPalette::Window, QBrush (transparentcolor) );\n    QToolTip::setPalette( tooltippalette );\n\n    QGraphicsScene canvas(0,0,8000,6000);\n\n    if (useGUI) {\n         main_window=new Main(canvas, mesh);\n      if ( QApplication::desktop()->width() > ((Main *)main_window)->width() + 10\n	   &amp;&amp; QApplication::desktop()->height() > ((Main *)main_window)->height() +30 ) {\n\n	((Main *)main_window)->show();\n	((Main *)main_window)->resize( ((Main *)main_window)->sizeHint());\n    } else {\n        ((Main *)main_window)->showMaximized();\n    }\n  } else {\n        main_window=new MainBase(canvas, mesh);\n\n }\n\n    \n	  \n    canvas.setSceneRect(QRectF());\n    if (!batch) {\n      QObject::connect( qApp, SIGNAL(lastWindowClosed()), qApp, SLOT(quit()) );\n    }\n\n						\n 		\n    main_window->Init(leaffile);\n	  \n    Cell::SetMagnification(1);\n    Cell::setOffset(0,0);\n						\n    main_window->FitLeafToCanvas();\n						\n				\n						\n    main_window->Plot();\n\n						\n\n    if (batch) {\n      double t=0.;\n      do {\n	t = main_window->TimeStep();\n      } while (t < par.maxt);\n							\n    } else\n      return app.exec();\n	  \n						\n  } catch (const char *message) {\n    if (batch) { \n      cerr << \"Exception caught:\" << endl;\n      cerr << message << endl;\n      abort();\n    } else {\n      QString qmess=QString(\"Exception caught: %1\").arg(message);\n      QMessageBox::critical(0, \"Critical Error\", qmess);\n      abort();\n    }\n  } catch (ios_base::failure) {\n    stringstream error_message;\n    error_message << \"I/O failure: \" << strerror(errno);\n    if (batch) {\n      cerr << error_message.str() <<endl;\n      abort();\n    } else {\n      QString qmess(error_message.str().c_str());\n      QMessageBox::critical(0, \"I/O Error\", qmess );\n      abort();\n    }\n  }\n					\n}\n";
    xmlNodePtr xmlcode = xmlNewChild(parent, NULL, BAD_CAST "code", sourcecode);

     {
        xmlNewProp(xmlcode, BAD_CAST "name", BAD_CAST "VirtualLeaf.cpp");
     }
  
}

void XMLIO::XMLWriteReactionsCode(xmlNode *parent) {

xmlChar *sourcecode = (xmlChar *)"\n\n// Executed after the cellular mechanics steps have equillibrized\nclass CellHouseKeeping {\npublic:\n	void operator() (Cell &amp;c) const {\n		\n		c.EnlargeTargetArea(par.cell_expansion_rate);\n		\n		if (c.Area() > par.rel_cell_div_threshold * c.BaseArea() ) {\n			c.Divide();\n		}\n	}\n};\n\n// The number of chemical species in the cels\nconst int Cell::nchem = 0;\n\n// Differential equations describing transport of chemicals from cell to cell\nclass CelltoCellTransport : public TransportFunction {\n\n public:\n	virtual void operator()(Wall *w, double *dchem_c1, double *dchem_c2) {}\n    \n };\n\n// Differential equations describing chemical reactions taking place at or near the cell walls\n// (e.g. PIN accumulation)\nclass WallDynamics : public WallReaction {\n public:\n	virtual void operator()(Wall *w, double *dw1, double *dw2) {}; \n	\n};\n\n\n// Differential equations describing chemical reactions inside the cells\nclass CellDynamics : public CellReaction {\n public:\n	virtual void operator()(Cell *c, double *dchem) {\n	\n	};\n	\n};\n\n// Rules for cell coloring\nvoid Cell::SetColor(QColor &amp;color) { }\n\n// To be executed after cell division\nvoid Cell::OnDivide(ParentInfo &amp;parent_info, Cell &amp;daughter) {}\n\n";
    xmlNodePtr xmlcode = xmlNewChild(parent, NULL, BAD_CAST "code", sourcecode);

     {
        xmlNewProp(xmlcode, BAD_CAST "name", BAD_CAST "reactions_pce_growth.h");
     }
  
}

